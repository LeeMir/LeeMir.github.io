---
title: 컴퓨터구조론#4
author: LeeMir
layout: post
category: [ computer-structure ]
---

## 2장 - CPU의 구조와 기능(이어서)

- - -

###### 명령어 파이프라이닝(Instruction pipelining)

- CPU의 프로그램 처리 속도를 높이기 위하여 CPU 내부 하드웨어를 여러 단계로 나누어 동시에 처리하는 기술

- 4-단계 명령어 파이프라인

  - 명령어 인출(IF) 단계 : 다음 명령어를 기억장치로부터 인출
  - 명령어 해독(ID) 단계 : 해독기(decoder)를 이용하여 명령어를 해석
  - 오퍼랜드 인출(OF) 단계 : 기억장치로부터 오퍼랜드를 인출
  - 실행(EX) 단계 : 지정된 연산을 수행
  - 각 단계에 걸리는 클록 주기는 모두 같아야 파이프라이닝이 가능
    - 그러므로 가장 오래 걸리는 단계에 다른 단계들이 맞춰서 주기를 수정해야하는데, 그러면 비효율적이 됨
    - 최대한 각 단계에 걸리는 클록 주기를 최소로 하는게 핵심

- 속도 향상

  - > 파이프 라인의 단계 수 : K 단계
    >
    > 전체 실행될 명령어들의 수 : N 개
    >
    > 각 단계의 소요시간 : 1 클럭 주기

  - 파이프라이닝 기술이 적용된 실행 시간

    - > T = K + (N - 1)

  - 파이프라이닝 기술이 적용되지 않은 실행 시간

    - > T = K * N

  - 속도 향상

    - > S = (K * N) / K + (N - 1)
      >
      > => K가 무한으로 갈경우, N에 수렴함

- 파이프라인의 효율 저하 요인
  - 모든 명령어들이 파이프라인 단계들을 모두 거치지는 않음
    - 어떤 명령어에서는 오퍼랜드를 인출할 필요가 없지만, 파이프라인의 하드웨어를 단순화시키기 위해서는 모든 명령어가 네 단계들을 모두 통과하도록 해야해 불필요한 과정이 생길 수 있음
  - 파이프라인의 클록은 처리시간이 가장 오래 걸리는 단계를 기준으로 결정
  - IF 단계와 OF 단계가 동시에 기억장치를 액세스하는 경우에, 기억장치 충돌이 일어나면 지연이 발생
  - 조건 분기 명령어(JUMP)가 실행되면, 미리 인출하여 처리하던 명령어들이 무효화됨
    - 분기 예측
      - 분기가 일어날 것인지를 예측하고, 그에 따라 명령어를 인출하는 확률적 방법(정적)
      - 분기 역사 표(branch history table) 이용하여 최근의 분기 결과를 참조(동적)
    - 분기 목적지 선인출(prefetch branch target)
      - 조건 분기가 인식되면, 분기 명령어의 다음 명령어뿐만 아니라 분기의 목적지 명령어도 함께 인출하여 실행하는 방법
        - 조건 확인 후, 유효 명령어 결과를 선택
    - 루프 버퍼(loop buffer) 사용
      - 파이프라인의 명령어 인출 단계에 포함되어 있는 작은 고속 기억장치인 루프 버퍼에 가장 최근 인출된 n개의 명령어들을 순서대로 저장해두는 방법
      - 만약 분기가 발생하면, 하드웨어는 먼저 분기 목적지의 명령어가 버퍼에 있는지를 검사하고 만약 있다면 다음 명령어는 루프로부터 인출
    - 지연 분기
      - 분기 명령어의 위치를 재배치함으로써 파이프라인의 성능을 개선하는 방법
        - 분기를 미리 실행해 재구성



###### 명령어 세트

- 어떤 CPU를 위하여 정의되어 있는 명령어들의 집합

- 명령어 세트 설계를 위해 결정되어야할 사항들

  - 연산 종류(operation repertoire) : CPU가 수행할 연산들의 수와 종류 및 복잡도
    - op의 비트수를 결정
  - 데이터 형태(data type) : 연산을 수행할 데이터들의 형태, 데이터의 길이(비트 수), 수의 표현 방식 등
  - 명령어 형식(instruction format) : 명령어의 길이, 오퍼랜드 필드들의 수와 길이, 등
  - 주소지정 방식(addressing mode) : 오퍼랜드의 주소를 지정하는 방식

- 연산의 종류

  - 데이터 전송 : 레지스터와 레지스터 간, 레지스터와 기억장치 간, 혹은 기억장치와 기억장치 간에 데이터를 이동하는 동작(ex : MOV)
  - 산술 연산 : 덧셈, 뺄셈, 곱셈 및 나눗셈과 같은 기본적인 산술 연산들
  - 논리 연산 : 데이터의 각 비트들 간에 대한 AND, OR, NOT 및 XOR 연산
    - 산술연산과 논리연산은 ALU가 관장함
  - 입출력(I/O) : CPU와 외부 장치들 간의 데이터 이동을 위한 동작들
  - 프로그램 제어
    - 명령어 실행 순서를 변경하는 연산들
    - 분기(branch), 서브루틴 호출(subroutine call)

- 명령어 형식

  - 명령어 내 필드들의 수와 배치 방식 및 각 필드의 비트 수
  - 필드 : 명령어의 각 구성 요소들에 소요되는 비트들의 그룹
  - 명령어의 구성요소들
    - 연산 코드(Operation Code) : 수행될 연산을 지정 (ex : LOAD, ADD)
    - 오퍼랜드(Operand)
      - 연산을 수행하는 데 필요한 데이터 혹은 데이터의 주소
      - 각 연산은 한 개 혹은 두 개의 입력 오퍼랜드들과 한 개의 결과 오퍼랜드를 포함
      - 데이터는 CPU 레지스터, 주기억장치, 혹은 I/O 장치에 위치
    - 다음 명령어 주소(Next Instruction Address)
      - 현재의 명령어 실행이 완료된 후에 다음 명령어를 인출할 위치 지정
      - 분기 혹은 호출 명령어와 같이 실행 순서를 변경하는 경우에 필요
  - 명령어의 길이 = 단어(word) 길이 = CPU에서 한번에 처리할 수 있는 데이터의 길이
    - 연산 코드 필드 길이 : 연산의 개수를 결정
      - 만약 연산 코드 필드가 5 비트라면, 2^(5) = 32가지 연산들을 정의할 수 있음
        - 단, 다른 필드의 길이가 감소
    - 오퍼랜드 필드의 길이 : 오퍼랜드의 범위 결정
      - 오퍼랜드의 종류에 따라 범위가 달라짐
        - 데이터 : 표현 가능한 수의 범위 결정
        - 기억장치 주소 : CPU가 오퍼랜드 인출을 위하여 직접 주소를 지정할 수 있는 기억장치 용량 결정
        - 레지스터 번호 : 데이터 저장에 사용될 수 있는 레지스터의 개수 결정
      - 오퍼랜드 2개를 하나로 통합하여 사용할 수도 있음
        - 항상 표현 범위를 잘 생각할 것
          - 주소나 레지스터 번호가 아닌 데이터의 경우에는 2의 보수로 표현할 수도 있음
  - 1-주소 명령어를 사용한 프로그램
    - 피연산 대상은 암묵적으로 AC
  - 2-주소 명령어를 사용한 프로그램
    - 피연산 대상은 첫번째 오퍼랜드
  - 3-주소 명령어를 사용한 프로그램
    - 피연산 대상은 첫번째 오퍼랜드
    - 프로그램의 길이는 짧아지나, 명령어의 길이가 증가하고 명령어를 해독하는 과정이 복잡해지는 단점이 존재

- 주소지정 방식(addressing mode)

  - 명령어 실행에 필요한 오퍼랜드의 주소를 결정하는 방식

  - 다양한 주소지정 방식을 사용하는 이유

    - 제한된 수의 명령어 비트들을 이용하여, 사용자(프로그래머)가 여러 가지 방법으로 오퍼랜드의 주소를 결정하도록 해주며, 더 큰 용량의 기억장치를 사용할 수 있도록 하기 위함

  - 명령어 내 오퍼랜드 필드의 내용

    - 기억장치 주소 : 데이터가 저장된 기억장치의 위치를 지정
    - 레지스터 번호 : 데이터가 저장된 레지스터를 지정
    - 데이터 : 명령어의 오퍼랜드 필드에 데이터가 포함

  - 직접 주소지정 방식

    - EA = A
    - 단점 : 기억장치가 한정되어 있어서 많은 수의 데이터를 기억장치에 저장할 수 없음

  - 간접 주소지정 방식

    - EA = (A)
    - 장점 : 단어 길이가 n비트라면, 최대 2^(n)개의 기억 장소에 대한 주소 지정이 가능
    - 단점 : 실행 사이클 동안에 두 번의 기억장치 액세스가 필요

  - 묵시적 주소지정 방식

    - 명령어 실행에 필요한 데이터의 위치가 묵시적으로 지정되는 방식

    - > ex : SHL => AC의 내용을 좌측으로 시프트
      >
      > ​       PUSH R1 => 레지스터 R1의 내용을 스택에 저장
      >
      > ​                             (SP가 가리키는 기억장소에 R1의 내용을 저장한다는 것이 묵시적으로 정해져 있음)

    - 장점 : 명령어 길이가 짧음

    - 단점 : 종류가 제한됨

  - 즉시 주소지정 방식

    - 데이터가 명령어에 포함되어 있는 방식
    - 프로그램에서 레지스터나 변수의 초기 값을 어떤 상수값(constant value)으로 세트하는 데 사용
    - 장점 : 데이터를 인출하기 위하여 기억장치를 액세스할 필요가 없어 속도가 빠름
    - 단점 : 상수값의 크기가 오퍼랜드 필드의 비트 수에 의해 제한됨

  - 레지스터 주소지정 방식

    - 연산에 사용될 데이터가 내부 레지스터에 저장되어 있는 경우, 명령어의 오퍼랜드가 해당 레지스터를 가리키는 방식
    - EA = R
    - 장점 : 오퍼랜드 필드의 비트 수가 적어도 되고, 데이터 인출을 위해 기억장치 액세스가 필요 없음
    - 단점 : 데이터가 저장될 수 있는 공간이 CPU 내부 레지스터들로 제한됨

  - 레지스터 간접 주소지정 방식

    - 오퍼랜드 필드(레지스터 번호)가 가리키는 레지스터의 내용을 유효 주소로 사용하여 실제 데이터를 인출하는 방식
    - EA = (R)
    - 장점 : 주소지정할 수 있는 기억장치 영역이 확장
    - 간접 주소지정 방식과 비교해, 기억장치에 한번만 접근해도 돼 속도가 상대적으로 빠름

  - 변위 주소지정 방식

    - 직접 주소지정과 레지스터 간접 주소지정 방식의 조합

    - EA = A + (R)

    - 사용되는 레지스터에 따라 여러 종류의 변위 주소지정 방식 가능

      - PC => 상대 주소지정 방식

        - 프로그램 카운터(PC)를 레지스터로 사용하여 EA를 계산
        - EA = A + (PC) // 이 때 A는 2의 보수
        - 주로 분기 명령어에서 사용
        - 장점 : 전체 기억장치 주소가 명령어에 포함되어야 하는 일반적인 분기 명령어보다 적은 수의 비트만 필요
        - 단점 : 분기 범위가 오퍼랜드 필드의 길이에 의해 제한(오퍼랜드 비트들로 표현 가능한 2의 보수 범위)

      - 인덱스 레지스터 => 인덱스 주소지정 방식

        - 인덱스 레지스터의 내용과 변위 A를 더하여 유효 주소를 결정

        - EA = (IX) + A

        - 배열 데이터에 액세스할 때 주로 사용

        - 자동 인덱싱

          - 명령어가 실행될 때마다 인덱스 레지스터의 내용이 자동적으로 증가 혹은 감소

          - 이 방식이 사용된 명령어가 실행되면 다음 두 명령어가 연속적으로 실행

          - > EA = (IX) + A
            >
            > IX = IX + 1

      - 베이스-레지스터 주소지정 방식

        - 베이스 레지스터의 내용과 변위 A를 더하여 유효 주소를 결정

        - EA = (BR) + A

        - 프로그램의 위치를 지정하거나 변경할 때 사용

          

LOAD D

SUB E

STOR T

LOAD A

MUL B

ADD C

DIV T



6

6

36

